#!/bin/sh

# DASH Tools to manipulate IPv6 addresses. This version is using non ARRAY workaround to be more portable over the systems
# DHClient is using by default /bin/sh which in Debian for example is using DASH. Trying to use the BASH version will
# DASH commands needes by this script:
#  1. DASH or similar shell interpreter
#  2. printf builtin of from coreutils
#  3. sed from coreutils
#  4.
#
# Avaiable functions:
#  1. ipv6_compression					- Returns a compress format of an IPv6
#  2. ipv6_leading_zero_compression		- Returns a compress format of an IPv6 from leading 0s.
#  3. ipv6_uncompress					- Returns an uncompressed format of an IPv6.
#  4. ipv6_first_subnet_address			- Returns the first IPv6 address of a given IPv6 subnet.
#  5. ipv6_last_subnet_address			- Returns the last IPv6 address of a given IPv6 subnet.
#  6. ipv6_check						- Checks if the given string is a valid IPv6 address.
#
# All functions needs first argument to be a valid IPv6 and second argument optional which is the name of a global variable (not the variable like $VAR, just VAR) where to store the result.
# In case the second argument is not given, will print the result to the stdout.
#
# All functions returns 0 in case the successful or 1 in case there is an error occured. A debug message to stderr will be displayed.
# The error must be treated by the main script, like exit the script or do something else.
#
# _echo_* functions can be override using _ECHO_* variable to point to another function
#
# Dash has an issue using IFS=$' \t\n', like BASH. Even I'm unset IFS, I'm still geting errors in my functions.
# To fix it we have to use:
#IFS=" \t
#"
#
# And in this way is setting <space><tab><newline> correctly.

if [ -z "${_DEBUG_}" ]; then
	_DEBUG_=0
else
	if [ "${_DEBUG_}" = "2" ]; then
		# Enable DASH script debugging
		set -x
	fi
	_DEBUG_=1
fi

if [ -z "${_ECHO_INFO}" ]; then
_echo_info()
{
	echo "INFO: $@" > /dev/stderr
}
_ECHO_INFO=_echo_info
fi

if [ -z "${_ECHO_WARNING}" ]; then
_echo_warning()
{
	echo "WARNING: $@" > /dev/stderr
}
_ECHO_WARNING=_echo_warning
fi

if [ -z "${_ECHO_DEBUG}" ]; then
_echo_debug()
{
	if [ ${_DEBUG_} -eq 1 ]; then
		echo "DEBUG: $@" > /dev/stderr
	fi
}
_ECHO_DEBUG=_echo_debug
fi

if [ -z "${_ECHO_ERROR}" ]; then
_echo_error()
{
	echo "ERROR: $@" > /dev/stderr
}
_ECHO_ERROR=_echo_error
fi

__set_IFS_default() {
	unset IFS
	IFS=" \t
"
}

__get_number_of_el_in_list()
{
	# To simulate an array like, we will use this function to walk through a list space-separated and return total number of elements.
	# Arguments:
	#   $1 - Name of the variable (can be local in a function or global) that contains the list. Use only just "VAR", not "$VAR"
	#
	# Optional Arguments:
	#   $2 - Name of variable (can be local in a function or global) where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#   0 - in case the was successful
	#   1 - in case there is an error.
	#
	# Outputs:
	# If $2 is defined, then the total number of elements will be store in this variable, otherwise to the standard output.
	#

	local __LIST_NAME_1__="$1"
	local __LIST_1__=""
	local __VAL__=""
	local __RETURN_VAR__="$2"
	local __IDX__
	local OLD_IFS

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	unset IFS
	__set_IFS_default

	if [ -z "${__LIST_NAME_1__}" ]; then
		return 1
	fi

	eval __LIST_1__=\$${__LIST_NAME_1__}

	__IDX__=0
	for VAL in ${__LIST_1__}; do
		__IDX__=$((__IDX__+=1))
	done

	if [ -n "${__RETURN_VAR__}" ]; then
		eval ${__RETURN_VAR__}=\${__IDX__}
	else
		echo ${__IDX__}
	fi

	# Restore previous IFS
	IFS=${OLD_IFS}

	return 0
}

__get_value_from_list_by_index()
{
	# To simulate an array like, we will use this function to walk through a list space-separated and return the value of the specific index.
	# Arguments:
	#   $1 - Name of the variable (can be local in a function or global) that contains the list. Use only just "VAR", not "$VAR"
	#   $2 - Index of which element we want to return. Starting from 0.
	#
	# Optional Arguments:
	#   $3 - Name of variable (can be local in a function or global) where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#   0 - in case the compression was successful
	#   1 - in case there is no match for the index given
	#

	# Keep __LIST_2 different from __LIST_1, Seems that is not working to use the same local variable in both functions.
	local __LIST_NAME_2__="$1"
	local __LIST_2__=""
	local __VAL__=""
	local __IDX_SEARCH__="$2"
	local __RETURN_VAR__="$3"
	local __RESULT__

	local __TOTAL_EL__

	local __IDX__

	local OLD_IFS

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	# This is working here as expected ..
	unset IFS
	__set_IFS_default

	if [ -z "${__LIST_NAME_2__}" ]; then
		${_ECHO_ERROR} "Argument 1 is empty!"
		return 1
	fi

	# Check if $2 is integer
	__RESULT__=$(echo ${__IDX_SEARCH__} | sed "s/[0-9]\+//")

	if [ -n "${__RESULT__}" ]; then
		${_ECHO_ERROR} "Argument 2 is not an integer!"
		return 1
	fi

	eval __LIST_2__=\$${__LIST_NAME_2__}

	__get_number_of_el_in_list "__LIST_2__" "__TOTAL_EL__"

	__IDX__=0
	for __VAL__ in ${__LIST_2__}; do
#		${_ECHO_DEBUG} "Current sub-block: ${__VAL__}"
#		${_ECHO_DEBUG} "__get_value_from_list_by_index(): __IDX__=${__IDX__}"
		if [ ${__IDX__} -eq ${__IDX_SEARCH__} ]; then
			break
		fi
		__IDX__=$((__IDX__+=1))
#		${_ECHO_DEBUG} "__get_value_from_list_by_index(): __IDX__=${__IDX__}"
	done

#	${_ECHO_DEBUG} "__get_value_from_list_by_index(): ${__TOTAL_EL__} vs ${__IDX__}"

	if [ ${__IDX__} -eq ${__TOTAL_EL__} ]; then
		return 1
	fi

	if [ -n "${__RETURN_VAR__}" ]; then
		eval ${__RETURN_VAR__}=\${__VAL__}
	else
		echo ${__VAL__}
	fi

	# Restore previous IFS
	IFS=${OLD_IFS}

	return 0
}

__add_el_to_list()
{
	# To simulate an array like, we will use this function to walk through a list space-separated and return the value of the specific index.
	# Arguments:
	#   $1 - Name of the variable (can be local in a function or global) that contains the list. Use only just "VAR", not "$VAR"
	#   $2 - New element to be added, without SPACES!
	#
	# Returns:
	#   0 - in case of successful
	#   1 - in case there was an error
	#

	# Keep __LIST_X different from other functions, Seems that is not working to use the same local variable in both functions.
	local __LIST_NAME_3__="$1"
	local __LIST_3__=""

	local OLD_IFS

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	unset IFS
	__set_IFS_default

	if [ -z "${__LIST_NAME_3__}" ]; then
		${_ECHO_ERROR} "Argument 1 is empty!"
		return 1
	fi

	if [ -z "${2}" ]; then
		${_ECHO_ERROR} "Argument 2 is empty!"
		return 1
	fi

	eval __LIST_3__=\$${__LIST_NAME_3__}

	if [ -z "${__LIST_3__}" ]; then
		__LIST_3__="${2}"
	else
		__LIST_3__="${__LIST_3__} ${2}"
	fi

	eval ${__LIST_NAME_3__}=\${__LIST_3__}

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}

}

ipv6_check()
{
	# Check if the given string is a valid IPv6
	# Arguments:
	#   $1 - IPv6 to be checked
	#
	# Returns:
	#   0 - if is a valid IPv6
	#   1 - if we found more that 2 compression delimiters "::"
	#   2 - if there are more than 8 sub-blocks
	#   3 - if there is sub-block with invalid hexa characters
	#   4 - if there is a sub-block with a value greater than 0xFFFF or 65535
	#

	local __IDX__
	local OLD_IFS

	local __IPv6__="$1"
	local __IPv6__2="${__IPv6__}"

	local __SUBBLOCK__
	local IPv6_TOTAL_SUBBLOCKS

	local __RESULT__

	local __IPv6_COMPRESS_SUBBLOCK__=0
	local __IPv6_ADD_GROUPS_0s__=0

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	__set_IFS_default

	# Split in 2 big sub-blocks: BEFORE and AFRTER
	IPv6_BEFORE_SUBBLOCKS=${__IPv6__%%::*}
	IPv6_AFTER_SUBBLOCKS=${__IPv6__#*::}

	# If in IPv6_AFTER_SUBBLOCKS we find again ::, then there is a double compression in IPv6 and we have to stop processing it. This is an invalid format
	if [ "${IPv6_AFTER_SUBBLOCKS}" != "${IPv6_AFTER_SUBBLOCKS#*::}" ]; then
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 1
	fi

	__IPv6__2=$(echo ${__IPv6__2} | sed "s/:/ /g")

	__get_number_of_el_in_list "__IPv6__2" "IPv6_TOTAL_SUBBLOCKS"

	if [ ${IPv6_TOTAL_SUBBLOCKS} -gt 8 ]; then
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 2
	fi

	for __SUBBLOCK__ in ${__IPv6__2}; do
		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 3
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")

		if [ ${__RESULT__} -gt 65535 ]; then
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 4
			break
		fi
	done

	return 0
}

ipv6_compression()
{
	# Compress IPv6 address.
	# Argumets:
	#   $1 - IPv6 address
	#
	# Optional Arguments:
	#   $2 - Name of variable where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#   0 - in case the compression was successful
	#   1 - in case there is an error in IPv6 format.
	#
	# Output:
	#   In case argument $2 is missing, print the result to output. Can be captured into a variable.
	#
	# Compress rules for an IPv6:
	# 1. That rule is also known as leading zero compression. You can remove the leading zeros (0s) in the 16 bits field of an IPv6 address. But each block in which you do that has at least one number remaining. If the field contains all zeros (0s), you must leave one zero (0) remaining. Removing leading zeros (0s) from the start does not have any effect on the value. However, you cannot apply that rule to trailing zeros (0s).
	# 2. That rule is also called the zero compression rule. According to that rule, if an IPv6 address contains continuous zeros, then they are replaced with (::), but only the longest continuous group of 0s!
	# Example : 1050:0000:0000:0000:0005:0000:0000:326b will be 1050:0:0:0:5:0:0:326b and in the end will be 1050::5:0:0:326b. Second group of 0s can't be compressed, becasue first group has 3 continuous 0s and the second one has only 2.
	# In case of tie, first one will be compressed.
	# 3. If zeros (0s) are present in a discontinuous pattern in IPv6 address, then at only one joining, the zeros (0s) are replaced with (::).

	local __IPv6__="$1"

	local __IDX__
	local OLD_IFS
#	local __VALUE__

	local __IPv6_SUBBLOCKS__=""
	local __IPv6_TOTAL_SUBBLOCKS__=""

	local __IPv6_FIRST_0s__=0

	# Vars to save start and stop of the longes 0s groups
	local IPv6_LONGEST_0s_START=0
	local IPv6_LONGEST_0s_END=0

	# Vars to save start and stop of the current group
	local IPv6_CURRENT_GROUP_START=0
	local IPv6_CURRENT_GROUP_END=0

	local __SUBBLOCK__
	local __SUBBLOCK_LEN__
	local __SUBBLOCK_START__=0
	local __TOTAL_SUBBLOCKS__=0
	local tmpIPv6="${__IPv6__}"

	local __RESULT__
	local __COMPRESSION__

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	__set_IFS_default

	# Using substrigs. Could be much faster and less complex.
	# In case we see ::, the address is already compressed. Just return it
	__COMPRESSION__=${__IPv6__%%::}

	if [ "${__IPv6__}" != "${__COMPRESSION__}" ]; then
		# Compression detected. Return the same IPv6
#		${_ECHO_DEBUG} "Compression detected: ${__IPv6__} vs ${__COMPRESSION__}"
		if [ -z "$2" ]; then
			echo "${__IPv6__}"
		else
			eval ${2}="${__IPv6__}"
		fi
		break
	fi

	# Loop until we don't have any sub-blocks. We will loop through the string by splitting it using ":" delimiter. If we have less than 8 or more sub-groups in __IPv6__, then there is something wrong with the IPv6 format!

	# Change IFS delimier to ":"
	IFS=":"
	for __SUBBLOCK__ in ${__IPv6__}; do

		__SUBBLOCK_LEN__=${#__SUBBLOCK__}

		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		#${_ECHO_DEBUG} "Subblock: "${__SUBBLOCK__}
		#${_ECHO_DEBUG} "Subblock len: "${__SUBBLOCK_LEN__}

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			${_ECHO_ERROR} "provided string ${IPv6} contains characters which are not valid HEXA value! Allowed characters are: 0-9, a-f and A-F only!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")

		if [ ${__RESULT__} -gt 65535 ]; then
			${_ECHO_ERROR} "provided string ${IPv6} contains subblocks with values greater than 0xFFFF, which is an invalid IPv6 format!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		if ! __add_el_to_list "__IPv6_SUBBLOCKS__" $(printf "%x" "${__RESULT__}"); then
			${_ECHO_ERROR} "Couldn't add element ${__SUBBLOCK__} to the list __IPv6_SUBBLOCKS__"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi
	done

	# Reset IFS to default
	__set_IFS_default

	__get_number_of_el_in_list "__IPv6_SUBBLOCKS__" "__TOTAL_SUBBLOCKS__"

#	${_ECHO_DEBUG} "__IPv6_SUBBLOCKS__: ${__IPv6_SUBBLOCKS__}"
#	${_ECHO_DEBUG} "__TOTAL_SUBBLOCKS__: ${__TOTAL_SUBBLOCKS__}"

	# Let's check if we have 8 sub-blocks. In case not, then the string is not a valid IPv6.
	if [ ${__TOTAL_SUBBLOCKS__} -lt 8 ]; then
#		${_ECHO_ERROR} "provided string ${IPv6} doesn't have 8 sub-blocks to match IPv6 format!"
#		${_ECHO_ERROR} "provid only uncompressed IPv6 for this tool."
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 1
	fi

	# Count each continuous groups of 0s sub-blocks. Store the start and end of this group in IPv6_CURRENT_GROUP_*
	__IPv6_FIRST_0s__=0
	__IDX__=0
	for __SUBBLOCK__ in ${__IPv6_SUBBLOCKS__}; do

		#${_ECHO_DEBUG} "We processing sub-block ${__SUBBLOCK__} on index ${__IDX__}"

		# DASH can't do HEXA checks. We need to change to decimal.
		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")

		# Check if current __SUBBLOCK__ is 0x0
		if [ ${__RESULT__} -eq 0 ]; then
			# Start to count how many continuous 0s sub-blocks we have
			# Is this the first 0 in the group? If yes, mark it in __IPv6_FIRST_0s__ and set the start group with __IDX__
			if [ ${__IPv6_FIRST_0s__} -eq 0 ]; then
				__IPv6_FIRST_0s__=1
				IPv6_CURRENT_GROUP_START=${__IDX__}
			else
				# If we already have a start of continuous 0s sub-blocks (marked in __IPv6_FIRST_0s__), update the current end with __IDX__.
				IPv6_CURRENT_GROUP_END=${__IDX__}
			fi

			# In case the IPv6 is ending in 0, we have to check this and add to calculation.
			if [ ${__IDX__} -eq $((${__TOTAL_SUBBLOCKS__}-1)) ]; then
				if [ $((${IPv6_CURRENT_GROUP_END}-${IPv6_CURRENT_GROUP_START})) -gt $((${IPv6_LONGEST_0s_END}-${IPv6_LONGEST_0s_START})) ]; then
					# New longer 0s group is ${IPv6_LONGEST_0s_GROUP}
					IPv6_LONGEST_0s_START=${IPv6_CURRENT_GROUP_START}
					IPv6_LONGEST_0s_END=${IPv6_CURRENT_GROUP_END}
				fi
			fi
		else
			# If current __SUBBLOCK__ is not 0x0, then reset __IPv6_FIRST_0s__ and check if the current number of continuous 0s sub-blocks is the longest one.
			if [ ${__IPv6_FIRST_0s__} -eq 1 ]; then
				# Reset FIRST 0 found
				__IPv6_FIRST_0s__=0
				# The new group of 0s is greater than previous one?
				if [ $((${IPv6_CURRENT_GROUP_END}-${IPv6_CURRENT_GROUP_START})) -gt $((${IPv6_LONGEST_0s_END}-${IPv6_LONGEST_0s_START})) ]; then
					# New longer 0s group is ${IPv6_LONGEST_0s_GROUP}
					IPv6_LONGEST_0s_START=${IPv6_CURRENT_GROUP_START}
					IPv6_LONGEST_0s_END=${IPv6_CURRENT_GROUP_END}
				fi
			fi
		fi
		__IDX__=$((__IDX__+=1))
	done

	${_ECHO_DEBUG} "Longest 0s group is located between index: ${IPv6_LONGEST_0s_START} and ${IPv6_LONGEST_0s_END}"
	${_ECHO_DEBUG} "Compute compressed IPv6.."

	# Let's build the new format of IPv6 using IPv6_LONGEST_0s_START and IPv6_LONGEST_0s_END to compact the IPv6
	__IPv6__=""
	__IDX__=0
	for __SUBBLOCK__ in ${__IPv6_SUBBLOCKS__}; do
#		${_ECHO_DEBUG} "Processing sub-block: ${__SUBBLOCK__} on index ${__IDX__}"
		if [ ${__IDX__} -ge ${IPv6_LONGEST_0s_START} -a ${__IDX__} -le ${IPv6_LONGEST_0s_END} ]; then
			if [ ${__IDX__} -eq ${IPv6_LONGEST_0s_START} ]; then
				__IPv6__="${__IPv6__}::"
#				${_ECHO_DEBUG} "Add delimiter ::"
			fi
#			${_ECHO_DEBUG} "Sub-block skipped ${__SUBBLOCK__}"
			__IDX__=$((__IDX__+=1))
			continue
		fi
		# Don't add delimier in first sub-block or just after the "::"
		if [ ${__IDX__} -eq 0 -o ${__IDX__} -eq $((${IPv6_LONGEST_0s_END}+1)) ]; then
			__IPv6__="${__IPv6__}"$(printf "%x" 0x${__SUBBLOCK__})
		else
			__IPv6__="${__IPv6__}"$(printf ":%x" 0x${__SUBBLOCK__})
		fi
		__IDX__=$((__IDX__+=1))
	done

	if [ -z "$2" ]; then
		echo "${__IPv6__}"
	else
		eval ${2}="${__IPv6__}"
	fi

	# Restore previous IFS
	IFS=${OLD_IFS}

	return 0
}

ipv6_uncompress()
{
	# Uncompress/expand IPv6
	# Arguments:
	#   $1 - IPv6 to be expanded
	#
	# Optional Arguments:
	#   $2 - Name of global variable where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#   0 - in case uncompress was successful.
	#   1 - in case the IPv6 address is invalid.
	#
	# Output:
	#   In case argument $2 is missing, print the result to output.

	local __IDX__
	local OLD_IFS

	local __IPv6__="$1"

	local __IPv6_COMPRESS_SUBBLOCK__=0
	local __IPv6_ADD_GROUPS_0s__=0

	# Number of groups before and after compression. Needed for computation for decompression.
	local IPv6_BEFORE_SUBBLOCKS=""
	local IPv6_AFTER_SUBBLOCKS=""
	local IPv6_BEFORE_TOTAL_SUBBLOCKS=""
	local IPv6_AFTER_TOTAL_SUBBLOCKS=""
	local IPv6_TOTAL_SUBBLOCKS=0

	# Each IPv6 uncompressed must have 7 delimiters

	local __SUBBLOCK__
	local __SUBBLOCK_LEN__
	local __newIPv6__="${__IPv6__}"


	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	__set_IFS_default

	#${_ECHO_DEBUG} "IPv6 ${tmpIPv6}"

	# Split in 2 big sub-blocks: BEFORE and AFRTER
	IPv6_BEFORE_SUBBLOCKS=${__IPv6__%%::*}
	IPv6_AFTER_SUBBLOCKS=${__IPv6__#*::}

	__newIPv6__=$(echo ${__newIPv6__} | sed "s/:/ /g")

	__get_number_of_el_in_list "__newIPv6__" "IPv6_TOTAL_SUBBLOCKS"

	if [ ${IPv6_TOTAL_SUBBLOCKS} -gt 8 ]; then
		${_ECHO_ERROR} "provided IPv6 ${__IPv6__} has more than 8 sub-blocks! Please check your IPv6."
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 1
	fi

	${_ECHO_DEBUG} "Before Sub-blocks: ${IPv6_BEFORE_SUBBLOCKS}"
	${_ECHO_DEBUG} "After Sub-blocks : ${IPv6_AFTER_SUBBLOCKS}"

	# If both BEFORE and AFTER are the same, there is no compression
	if [ "${IPv6_BEFORE_SUBBLOCKS}" = "${IPv6_AFTER_SUBBLOCKS}" ]; then
		# Return uncompressed IPv6 with compressed leading 0s
		if [ -z "$2" ]; then
			echo "${__IPv6__}"
		else
			eval ${2}="${__IPv6__}"
		fi
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 0
	fi

	# If in IPv6_AFTER_SUBBLOCKS we find again ::, then there is a double compression in IPv6 and we have to stop processing it. This is an invalid format
	if [ "${IPv6_AFTER_SUBBLOCKS}" != "${IPv6_AFTER_SUBBLOCKS#*::}" ]; then
		{ECHO_ERROR} "privided string ${__IPv6__} contains multiple compression delimiters \"::\". Please check your IPv6."
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 1
	fi

	# Let's calculate how many groups of 0s we need to add to our IPv6.
	# Replace delimiter ":" with spaces
	IPv6_BEFORE_SUBBLOCKS=$(echo ${IPv6_BEFORE_SUBBLOCKS} | sed "s/:/ /g")
	IPv6_AFTER_SUBBLOCKS=$(echo ${IPv6_AFTER_SUBBLOCKS} | sed "s/:/ /g")

	${_ECHO_DEBUG} "Before Sub-blocks: ${IPv6_BEFORE_SUBBLOCKS}"
	${_ECHO_DEBUG} "After Sub-blocks : ${IPv6_AFTER_SUBBLOCKS}"

	if ! __get_number_of_el_in_list "IPv6_BEFORE_SUBBLOCKS" "IPv6_BEFORE_TOTAL_SUBBLOCKS"; then
		${_ECHO_ERROR} "an error occured when we tried to count number of sub-blocks before compression!"
		return 1
	fi
	if ! __get_number_of_el_in_list "IPv6_AFTER_SUBBLOCKS" "IPv6_AFTER_TOTAL_SUBBLOCKS"; then
		${_ECHO_ERROR} "an error occured when we tried to count number of sub-blocks after compression!"
		return 1
	fi

	IPv6_TOTAL_SUBBLOCKS=$((${IPv6_BEFORE_TOTAL_SUBBLOCKS}+${IPv6_AFTER_TOTAL_SUBBLOCKS}))
	__IPv6_ADD_GROUPS_0s__=$((8-${IPv6_TOTAL_SUBBLOCKS}))

	${_ECHO_DEBUG} "Total number of sub-blocks before compression: ${IPv6_BEFORE_TOTAL_SUBBLOCKS}."
	${_ECHO_DEBUG} "Total number of sub-blocks after compression : ${IPv6_AFTER_TOTAL_SUBBLOCKS}"
	${_ECHO_DEBUG} "Total IPv6 sub-blocks : ${IPv6_TOTAL_SUBBLOCKS}"
	${_ECHO_DEBUG} "We need to add ${__IPv6_ADD_GROUPS_0s__} of 0s groups."
	${_ECHO_DEBUG} "IPv6_BEFORE_SUBBLOCKS=\"${IPv6_BEFORE_SUBBLOCKS}\""

	__IPv6__=""
	# Loop until we don't have any sub-blocks.
	__IDX__=0

	# Compute first part of IPv6 using BEFORE sub-blocks
	for __SUBBLOCK__ in ${IPv6_BEFORE_SUBBLOCKS}; do

		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		${_ECHO_DEBUG} "Subblock: "${__SUBBLOCK__}
		#${_ECHO_DEBUG} "Subblock len: "${__SUBBLOCK_LEN__}

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			${_ECHO_ERROR} "provided string ${__IPv6__} contains characters which are not valid HEXA value! Allowed characters are: 0-9, a-f and A-F only!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")
		if [ ${__RESULT__} -gt 65535 ]; then
			${_ECHO_ERROR} "provided string ${IPv6} contains a subblock (${__SUBBLOCK__}) with values greater than 0xFFFF, which is an invalid IPv6 format!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		#SUBBLOCK_LEN=${#__SUBBLOCK__}

		if [ -z "${__IPv6__}" ]; then
			__IPv6__=$(printf "%x" ${__RESULT__})
		else
			__IPv6__=$(printf "%s:%x" "${__IPv6__}" ${__RESULT__})
		fi
		__IDX__=$((__IDX__+=1))
	done

	${_ECHO_DEBUG} "Partial uncompressed IPv6: ${__IPv6__}"

	# Compute compression IPv6 by repace compression delimiter "::" with 0s sub-blocks
	for __SUBBLOCK__ in `seq 1 ${__IPv6_ADD_GROUPS_0s__}`; do
		if [ -z "${__IPv6__}" ]; then
			__IPv6__="0"
		else
			__IPv6__="${__IPv6__}:0"
		fi
	done

	# Compute last part of IPv6 using BEFORE sub-blocks
	for __SUBBLOCK__ in ${IPv6_AFTER_SUBBLOCKS}; do

		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		${_ECHO_DEBUG} "Subblock: "${__SUBBLOCK__}
		#${_ECHO_DEBUG} "Subblock len: "${__SUBBLOCK_LEN__}

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			${_ECHO_ERROR} "provided string ${__IPv6__} contains characters which are not valid HEXA value! Allowed characters are: 0-9, a-f and A-F only!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")
		if [ ${__RESULT__} -gt 65535 ]; then
			${_ECHO_ERROR} "provided string ${IPv6} contains a subblock (${__SUBBLOCK__}) with values greater than 0xFFFF, which is an invalid IPv6 format!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		if [ -z "${__IPv6__}" ]; then
			__IPv6__=$(printf "%x" ${__RESULT__})
		else
			__IPv6__=$(printf "%s:%x" "${__IPv6__}" ${__RESULT__})
		fi
		__IDX__=$((__IDX__+=1))
	done

	# Post-checks:

	# Return uncompressed IPv6 with compressed leading 0s
	if [ -z "$2" ]; then
		echo "${__IPv6__}"
	else
		eval ${2}="${__IPv6__}"
	fi

	# Restore previous IFS
	IFS=${OLD_IFS}

	return 0
}

ipv6_leading_zero_compression()
{
	# Remove leading zeros from each sub-block of the IPv6
	# Arguments:
	#   $1 - IPv6 to remove leading zeros.
	#
	# Optional Arguments:
	#   $2 - Name of global variable where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#    0 - in case leading zero compression was successful.
	#    1 - in case the IPv6 address is invalid.
	#
	# Output:
	#   In case argument $2 is missing, print the result to output.

	local IDX
	local OLD_IFS

	local __IPv6__="$1"
	local IPv6_COMPRESS_SUBBLOCK=0

	local IPv6_BEFORE_SUBBLOCKS=""
	local IPv6_AFTER_SUBBLOCKS=""

	local __SUBBLOCK__
	local SUBBLOCK_LEN

	# Reset IFS to default. Sometimes if IFS is set somewhere in the code, can lead to errors!
	OLD_IFS=${IFS}
	__set_IFS_default

	# Split in 2 big sub-blocks: BEFORE and AFRTER
	IPv6_BEFORE_SUBBLOCKS=${__IPv6__%%::*}
	IPv6_AFTER_SUBBLOCKS=${__IPv6__#*::}

	# If in IPv6_AFTER_SUBBLOCKS we find again ::, then there is a double compression in IPv6 and we have to stop processing it. This is an invalid format
	if [ "${IPv6_AFTER_SUBBLOCKS}" != "${IPv6_AFTER_SUBBLOCKS#*::}" ]; then
		{ECHO_ERROR} "privided string ${__IPv6__} contains multiple compression delimiters \"::\". Please check your IPv6."
		# Restore previous IFS
		IFS=${OLD_IFS}
		return 1
	fi

	# Let's calculate how many groups of 0s we need to add to our IPv6.
	# Replace delimiter ":" with spaces
	IPv6_BEFORE_SUBBLOCKS=$(echo ${IPv6_BEFORE_SUBBLOCKS} | sed "s/:/ /g")
	IPv6_AFTER_SUBBLOCKS=$(echo ${IPv6_AFTER_SUBBLOCKS} | sed "s/:/ /g")

	__IPv6__=""

	for __SUBBLOCK__ in ${IPv6_BEFORE_SUBBLOCKS}; do
		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		${_ECHO_DEBUG} "Subblock: "${__SUBBLOCK__}
		#${_ECHO_DEBUG} "Subblock len: "${__SUBBLOCK_LEN__}

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			${_ECHO_ERROR} "provided string ${__IPv6__} contains characters which are not valid HEXA value! Allowed characters are: 0-9, a-f and A-F only!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")
		if [ ${__RESULT__} -gt 65535 ]; then
			${_ECHO_ERROR} "provided string ${__IPv6__} contains a subblock (${__SUBBLOCK__}) with values greater than 0xFFFF, which is an invalid IPv6 format!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		if [ -z "${__IPv6__}" ]; then
			__IPv6__=$(printf "%x" ${__RESULT__})
		else
			__IPv6__=$(printf "%s:%x" "${__IPv6__}" ${__RESULT__})
		fi
		__IDX__=$((__IDX__+=1))
	done

	if [ "${IPv6_BEFORE_SUBBLOCKS}" = "${IPv6_AFTER_SUBBLOCKS}" ]; then
		# Return zero leading removed IPv6
		if [ -z "$2" ]; then
			echo "${__IPv6__}"
		else
			eval ${2}="${__IPv6__}"
		fi

		# Restore previous IFS
		IFS=${OLD_IFS}

		return 0
	fi

	# Add additional ":" to form compression delimiter "::"
	__IPv6__="${__IPv6__}:"

	for __SUBBLOCK__ in ${IPv6_AFTER_SUBBLOCKS}; do
		# Check if the sub-group is hexa
		__RESULT__=$(echo ${__SUBBLOCK__} | sed "s/[0-9a-fA-F]\+//")

		${_ECHO_DEBUG} "Subblock: "${__SUBBLOCK__}
		#${_ECHO_DEBUG} "Subblock len: "${__SUBBLOCK_LEN__}

		# Check if the sub-block contains only HEX characters
		if [ -n "${__RESULT__}" ]; then
			${_ECHO_ERROR} "provided string ${__IPv6__} contains characters which are not valid HEXA value! Allowed characters are: 0-9, a-f and A-F only!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		__RESULT__=$(printf "%d" "0x${__SUBBLOCK__}")
		if [ ${__RESULT__} -gt 65535 ]; then
			${_ECHO_ERROR} "provided string ${IPv6} contains a subblock (${__SUBBLOCK__}) with values greater than 0xFFFF, which is an invalid IPv6 format!"
			# Restore previous IFS
			IFS=${OLD_IFS}
			return 1
			break
		fi

		if [ -z "${__IPv6__}" ]; then
			__IPv6__=$(printf "%x" ${__RESULT__})
		else
			__IPv6__=$(printf "%s:%x" "${__IPv6__}" ${__RESULT__})
		fi
		__IDX__=$((__IDX__+=1))
	done

	# Return zero leading removed IPv6
	if [ -z "$2" ]; then
		echo "${__IPv6__}"
	else
		eval ${2}="${__IPv6__}"
	fi

	# Restore previous IFS
	IFS=${OLD_IFS}

	return 0
}

ipv6_first_subnet_address()
{
	# Calculate the first address of IPv6 using the prefix
	# Arguments:
	#   $1 - IPv6 subnet (IPv6/PREFIX format).
	#
	# Optional Arguments:
	#   $2 - Name of global variable where we will store the result. Use only just "VAR", not "$VAR"
	#
	# Returns:
	#   IPv6 first address of the subnet.
	#
	# Exits:
	#    1 - in case the IPv6 address is invalid.
	#
	# Output:
	#   In case argument $2 is missing, print the result to output.
	#
	# To simplify the maths, we are using an array which contains 16 types of prefix masks and we will map prefixes from 0 to 15 to this array
	# The array will contain:
	# 0x0000 (0000000000000000b), 0x8000 (1000000000000000b), 0xC000 (1100000000000000b), 0xE000 (1110000000000000b), 0xF000 (1111000000000000b), 0xF800 (1111100000000000b), 0xFC00 (1111110000000000b), 0xFE00 (1111111000000000b), 0xFF00 (1111111100000000b),
	# 0xFF80 (1111111110000000b), 0xFFC0 (1111111111000000b), 0xFFE0 (1111111111100000b), 0xFFF0 (1111111111110000b), 0xFFF8 (1111111111111000b), 0xFFFC (1111111111111100b), 0xFFFE (1111111111111110b)
	#
	# We are using 16 bits of mask because IPv6 has sub-blocks of 16 bits and will be easy to map each prefix sub-block to each uncompressed IPv6 sub-block.
	#
	# We will split the prefix in groups of 16 and reminder.
	# For example:
	#    Prefix 28: 28/16 = 1 and reminder 12. We will have only one group of 16 bits which by default will be 0xFFFF and second group will be 12 bits mapped to 0xFFF0 and the reset 0x0000.
	#    Prefix 48: 42/16 = 2 and reminder 10. We will have only two groups of 16 bits which by default will be 0xFFFF and third group will be 10 bits mapped to 0xFFC0 and the reset 0x0000.
	#

	local IDX
	local IPv6="$1"
	local IPv6_PREFIX
	local VAR_NAME=""

	local OLD_IFS

	# Prefix to mask mapping using index in array
	local PREFIX_MAP="0x0000 0x8000 0xC000 0xE000 0xF000 0xF800 0xFC00 0xFE00 0xFF00 0xFF80 0xFFC0 0xFFE0 0xFFF0 0xFFF8 0xFFFC 0xFFFE"

	local IPv6_SUBBLOCKS=( )
	# We will set IPv6 mask sub-blocks with 0x0000 by default
	local IPv6_MASK_SUBBLOCKS="0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000"
	local newValue

	:
}
